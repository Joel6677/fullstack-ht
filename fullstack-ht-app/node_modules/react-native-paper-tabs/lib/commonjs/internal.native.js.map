{"version":3,"sources":["internal.native.ts"],"names":["nothing","useAnimatedText","childrenCount","tabIndex","position","offset","textColor","activeColor","childrenA","Array","fill","undefined","positionWithOffset","Animated","add","inputRange","map","_","i","color","interpolate","outputRange","opacity","useIndicator","layouts","tabsLayout","style","current","transform","scaleX","width","translateX","cl","x","useOffsetScroller","index","updateScroll","mode","direction","React","useRef","useEffect","Platform","OS","id","addListener","nOffset","newOffset","value","oldDirection","removeListener"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport type {\n  AnimatedColorArgs,\n  AnimatedTextStyle,\n  AnimatedViewStyle,\n  IndicatorArgs,\n  IndicatorReturns,\n  OffsetScrollArgs,\n} from './utils';\nimport { Animated, Platform } from 'react-native';\n\nconst nothing = () => null;\n\nexport function useAnimatedText({\n  childrenCount,\n  tabIndex,\n  position,\n  offset,\n  textColor,\n  activeColor,\n}: AnimatedColorArgs): AnimatedTextStyle {\n  const childrenA = Array(childrenCount).fill(undefined);\n  const positionWithOffset = Animated.add(position!, offset!);\n  const inputRange = childrenA.map((_, i) => i);\n\n  return {\n    color: positionWithOffset.interpolate({\n      inputRange: inputRange,\n      outputRange: childrenA.map((_, i) =>\n        i === tabIndex ? activeColor : textColor\n      ),\n    }),\n    opacity: positionWithOffset.interpolate({\n      inputRange: inputRange,\n      outputRange: childrenA.map((_, i) => (i === tabIndex ? 1 : 0.6)),\n    }),\n  };\n}\n\nexport function useIndicator({\n  childrenCount,\n  position,\n  offset,\n  layouts,\n  tabsLayout,\n}: IndicatorArgs): IndicatorReturns {\n  const childrenA = Array(childrenCount).fill(undefined);\n  const positionWithOffset = Animated.add(position!, offset!);\n  const inputRange = childrenA.map((_, i) => i);\n  const style: AnimatedViewStyle | null =\n    position && tabsLayout && layouts.current\n      ? {\n          transform: [\n            {\n              scaleX: positionWithOffset.interpolate({\n                inputRange,\n                outputRange: childrenA.map(\n                  (_, i) => layouts.current?.[i]?.width || 0\n                ),\n              }),\n            },\n            {\n              translateX: positionWithOffset.interpolate({\n                inputRange,\n                outputRange: childrenA.map((_, i) => {\n                  const cl = layouts.current?.[i];\n                  if (!cl) {\n                    return 0;\n                  }\n                  return (cl.x + cl.width / 2) / cl.width;\n                }),\n              }),\n            },\n          ],\n        }\n      : null;\n\n  return [undefined, nothing, style];\n}\n\nexport function useOffsetScroller({\n  index,\n  offset,\n  updateScroll,\n  mode,\n}: OffsetScrollArgs) {\n  // we want native to scroll before the index changes\n  const direction = React.useRef<undefined | 'next' | 'prev'>(undefined);\n  React.useEffect(() => {\n    // android does not work unfortunately\n    if (offset && Platform.OS !== 'android' && mode === 'scrollable') {\n      const id = offset.addListener((nOffset) => {\n        const newOffset = nOffset.value;\n        const oldDirection = direction.current;\n\n        if (newOffset > 0.1) {\n          direction.current = 'next';\n        } else if (newOffset < -0.1) {\n          direction.current = 'prev';\n        }\n\n        if (direction.current) {\n          if (oldDirection !== direction.current) {\n            updateScroll(direction.current);\n          }\n        }\n      });\n      return () => {\n        offset.removeListener(id);\n      };\n    }\n    return undefined;\n  }, [offset, updateScroll, direction, mode]);\n\n  React.useEffect(() => {\n    direction.current = undefined;\n  }, [index]);\n}\n"]}