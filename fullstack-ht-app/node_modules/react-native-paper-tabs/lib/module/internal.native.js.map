{"version":3,"sources":["internal.native.ts"],"names":["React","Animated","Platform","nothing","useAnimatedText","childrenCount","tabIndex","position","offset","textColor","activeColor","childrenA","Array","fill","undefined","positionWithOffset","add","inputRange","map","_","i","color","interpolate","outputRange","opacity","useIndicator","layouts","tabsLayout","style","current","transform","scaleX","width","translateX","cl","x","useOffsetScroller","index","updateScroll","mode","direction","useRef","useEffect","OS","id","addListener","nOffset","newOffset","value","oldDirection","removeListener"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport type {\n  AnimatedColorArgs,\n  AnimatedTextStyle,\n  AnimatedViewStyle,\n  IndicatorArgs,\n  IndicatorReturns,\n  OffsetScrollArgs,\n} from './utils';\nimport { Animated, Platform } from 'react-native';\n\nconst nothing = () => null;\n\nexport function useAnimatedText({\n  childrenCount,\n  tabIndex,\n  position,\n  offset,\n  textColor,\n  activeColor,\n}: AnimatedColorArgs): AnimatedTextStyle {\n  const childrenA = Array(childrenCount).fill(undefined);\n  const positionWithOffset = Animated.add(position!, offset!);\n  const inputRange = childrenA.map((_, i) => i);\n\n  return {\n    color: positionWithOffset.interpolate({\n      inputRange: inputRange,\n      outputRange: childrenA.map((_, i) =>\n        i === tabIndex ? activeColor : textColor\n      ),\n    }),\n    opacity: positionWithOffset.interpolate({\n      inputRange: inputRange,\n      outputRange: childrenA.map((_, i) => (i === tabIndex ? 1 : 0.6)),\n    }),\n  };\n}\n\nexport function useIndicator({\n  childrenCount,\n  position,\n  offset,\n  layouts,\n  tabsLayout,\n}: IndicatorArgs): IndicatorReturns {\n  const childrenA = Array(childrenCount).fill(undefined);\n  const positionWithOffset = Animated.add(position!, offset!);\n  const inputRange = childrenA.map((_, i) => i);\n  const style: AnimatedViewStyle | null =\n    position && tabsLayout && layouts.current\n      ? {\n          transform: [\n            {\n              scaleX: positionWithOffset.interpolate({\n                inputRange,\n                outputRange: childrenA.map(\n                  (_, i) => layouts.current?.[i]?.width || 0\n                ),\n              }),\n            },\n            {\n              translateX: positionWithOffset.interpolate({\n                inputRange,\n                outputRange: childrenA.map((_, i) => {\n                  const cl = layouts.current?.[i];\n                  if (!cl) {\n                    return 0;\n                  }\n                  return (cl.x + cl.width / 2) / cl.width;\n                }),\n              }),\n            },\n          ],\n        }\n      : null;\n\n  return [undefined, nothing, style];\n}\n\nexport function useOffsetScroller({\n  index,\n  offset,\n  updateScroll,\n  mode,\n}: OffsetScrollArgs) {\n  // we want native to scroll before the index changes\n  const direction = React.useRef<undefined | 'next' | 'prev'>(undefined);\n  React.useEffect(() => {\n    // android does not work unfortunately\n    if (offset && Platform.OS !== 'android' && mode === 'scrollable') {\n      const id = offset.addListener((nOffset) => {\n        const newOffset = nOffset.value;\n        const oldDirection = direction.current;\n\n        if (newOffset > 0.1) {\n          direction.current = 'next';\n        } else if (newOffset < -0.1) {\n          direction.current = 'prev';\n        }\n\n        if (direction.current) {\n          if (oldDirection !== direction.current) {\n            updateScroll(direction.current);\n          }\n        }\n      });\n      return () => {\n        offset.removeListener(id);\n      };\n    }\n    return undefined;\n  }, [offset, updateScroll, direction, mode]);\n\n  React.useEffect(() => {\n    direction.current = undefined;\n  }, [index]);\n}\n"]}